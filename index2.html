<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BlockRoss</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&family=Pacifico&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Lora', serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    h1 {
      font-family: 'Pacifico', cursive;
      font-size: 48px;
      color: #2c3e50;
      margin: 20px 0;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }
    #info {
      margin: 20px;
      font-size: 18px;
      font-weight: 400;
      color: #333;
    }
    #main-canvas {
      margin: 20px auto;
    }
    #previous-blocks {
      margin: 20px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    .thumbnail {
      cursor: pointer;
      border: 1px solid #ccc;
      padding: 5px;
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .thumbnail:hover {
      border-color: #333;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    #description {
      margin: 20px auto;
      max-width: 600px;
      font-size: 16px;
      font-weight: 400;
      color: #333;
    }
    nav {
      margin: 10px;
    }
    nav a {
      color: #2980b9;
      text-decoration: none;
      font-weight: 700;
      margin: 0 10px;
    }
    nav a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <h1>BlockRoss</h1>
  <nav>
    <a href="index.html">Home</a>
    <a href="about.html">About</a>
  </nav>
  <div id="info">Fetching blockchain data...</div>
  <div id="main-canvas"></div>
  <div id="previous-blocks"></div>
  <div id="description">
    BlockRoss transforms Bitcoin's latest block data into unique art. Each piece is a digital interpretation of blockchain activity.
    <a href="about.html">Learn more about this project</a>.
  </div>
  <script>
    // Set random background gradient on load
    const gradients = [
      'linear-gradient(to bottom, #d0e4f5, #ffffff)', // Blue to white
      'linear-gradient(to bottom, #ffe4e1, #fffacd)', // Pink to cream
      'linear-gradient(to bottom, #e0f7e0, #f0fff0)', // Green to light green
      'linear-gradient(to bottom, #f0e6ff, #e6e6fa)', // Purple to lavender
      'linear-gradient(to bottom, #fff5e6, #ffe4b5)', // Orange to light yellow
      'linear-gradient(to bottom, #f5f5dc, #fffaf0)', // Beige to ivory
      'linear-gradient(to bottom, #e6f0ff, #f0f8ff)', // Light blue variations
      'linear-gradient(to bottom, #ffe6ff, #fff0f5)'  // Pink to pale pink
    ];
    document.body.style.background = gradients[Math.floor(Math.random() * gradients.length)];

    // Utility for fetch with timeout
    async function fetchWithTimeout(url, timeout = 5000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      try {
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(id);
        return response;
      } catch (error) {
        clearTimeout(id);
        throw error;
      }
    }

    // Fetch latest block data
    async function fetchBlockData() {
      try {
        const hashResponse = await fetchWithTimeout('https://mempool.space/api/blocks/tip/hash');
        const blockHash = await hashResponse.text();
        const heightResponse = await fetchWithTimeout('https://mempool.space/api/blocks/tip/height');
        const blockHeight = await heightResponse.text();
        return { blockHash, blockHeight };
      } catch (error) {
        console.error('Error fetching block data:', error);
        // Generate random fallback data
        const fallbackHash = '000000000000000000' + Math.random().toString(16).substr(2, 8);
        const fallbackHeight = Math.floor(700000 + Math.random() * 50000).toString();
        console.log('Using fallback data:', fallbackHash, fallbackHeight);
        return { blockHash: fallbackHash, blockHeight: fallbackHeight };
      }
    }

    // Fetch block height for polling
    async function fetchBlockHeight() {
      try {
        const response = await fetchWithTimeout('https://mempool.space/api/blocks/tip/height');
        return await response.text();
      } catch (error) {
        console.error('Error fetching block height:', error);
        return null;
      }
    }

    // Fetch previous blocks
    async function fetchPreviousBlocks() {
      try {
        const response = await fetchWithTimeout('https://mempool.space/api/blocks');
        const blocks = await response.json();
        return blocks.slice(1, 6).map(block => ({
          blockHash: block.id,
          blockHeight: block.height.toString()
        }));
      } catch (error) {
        console.error('Error fetching previous blocks:', error);
        // Generate random fallback blocks
        const fallbackBlocks = [];
        for (let i = 0; i < 5; i++) {
          const fallbackHash = '000000000000000000' + Math.random().toString(16).substr(2, 8);
          const fallbackHeight = (700000 - (i * 100) + Math.floor(Math.random() * 50)).toString();
          fallbackBlocks.push({ blockHash: fallbackHash, blockHeight: fallbackHeight });
        }
        return fallbackBlocks;
      }
    }

    // Convert randomizer string to a numerical seed
    function stringToSeed(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash = hash & hash; // Convert to 32-bit integer
      }
      return Math.abs(hash);
    }

    // Create randomizer string and seed
    function createRandomizer(hash, height) {
      const lastSix = hash.slice(-6);
      const randomizer = `${height}-${lastSix}`;
      const seed = stringToSeed(randomizer);
      return { randomizer, seed };
    }

    // Update info display
    function updateInfo(hash, height, randomizer, style) {
      const infoDiv = document.getElementById('info');
      infoDiv.innerHTML = `Block Height: ${height}<br>Block Hash (Last 6): ${hash.slice(-6)}<br>Randomizer: ${randomizer}<br>Style: ${style}`;
    }

    // Global variable to track current block height
    let currentBlockHeight = null;
    let mainSketch = null;

    // Fallback reload timer (6 minutes)
    let fallbackTimer = null;
    function setFallbackReload() {
      if (fallbackTimer) clearTimeout(fallbackTimer);
      fallbackTimer = setTimeout(() => {
        location.reload();
      }, 360000); // 6 minutes
    }

    // Poll for new block height
    function startBlockPolling() {
      setInterval(async () => {
        const newHeight = await fetchBlockHeight();
        if (newHeight && currentBlockHeight && newHeight !== currentBlockHeight) {
          location.reload(); // Reload on new block
        }
      }, 30000); // Poll every 30 seconds
    }

    // Setup different canvas styles
    function setupCanvas(p, canvasStyle) {
      if (canvasStyle === 'Standard') {
        // Default canvas - do nothing special
      } else if (canvasStyle === 'Circular') {
        // Create a circular mask
        p.drawingContext.save();
        p.drawingContext.beginPath();
        p.drawingContext.arc(p.width/2, p.height/2, p.min(p.width, p.height)/2, 0, Math.PI*2);
        p.drawingContext.clip();
      } else if (canvasStyle === 'Framed') {
        // Draw a decorative frame
        const frameSize = 30;
        p.fill(245, 245, 220); // Beige-like color
        p.stroke(139, 69, 19); // Brown
        p.strokeWeight(3);
        p.rect(0, 0, p.width, p.height);
        p.drawingContext.save();
        p.drawingContext.beginPath();
        p.drawingContext.rect(frameSize, frameSize, p.width - frameSize*2, p.height - frameSize*2);
        p.drawingContext.clip();
      } else if (canvasStyle === 'Divided') {
        // Divide the canvas into sections
        p.drawingContext.save();
        const sections = 2 + Math.floor(p.random(3)); // 2-4 sections
        if (p.random() > 0.5) {
          // Vertical sections
          const sectionWidth = p.width / sections;
          for (let i = 0; i < sections; i++) {
            p.drawingContext.beginPath();
            p.drawingContext.rect(i * sectionWidth, 0, sectionWidth, p.height);
            if (i % 2 === 0) {
              p.drawingContext.clip();
            }
          }
        } else {
          // Horizontal sections
          const sectionHeight = p.height / sections;
          for (let i = 0; i < sections; i++) {
            p.drawingContext.beginPath();
            p.drawingContext.rect(0, i * sectionHeight, p.width, sectionHeight);
            if (i % 2 === 0) {
              p.drawingContext.clip();
            }
          }
        }
      } else if (canvasStyle === 'Layered') {
        // Create a layered effect with a semi-transparent overlay
        p.drawingContext.save();
        const numLayers = 2 + Math.floor(p.random(2)); // 2-3 layers
        const overlayAlpha = 80 + Math.floor(p.random(40)); // 80-120
        p.fill(p.random(255), p.random(255), p.random(255), overlayAlpha);
        p.noStroke();
        for (let i = 0; i < numLayers; i++) {
          const x = p.random(-50, 50);
          const y = p.random(-50, 50);
          const w = p.width - Math.abs(x);
          const h = p.height - Math.abs(y);
          p.rect(Math.max(0, x), Math.max(0, y), w, h);
        }
      }
    }

    // Function to draw art (shared for main and thumbnails)
    function drawArt(p, blockHeight, style) {
      const heightFactor = parseInt(blockHeight) % 1000 / 1000;
      // Curated background color palette
      const bgColors = [
        [200, 220, 255], // Soft blue
        [255, 245, 200], // Light cream
        [220, 255, 220], // Pale green
        [255, 200, 220], // Soft pink
        [230, 230, 230], // Light gray
        [240, 230, 240], // Lavender
        [255, 235, 205], // Blanched almond
        [240, 248, 255], // Alice blue
        [220, 220, 220]  // Gainsboro
      ];
      const bgColor = bgColors[Math.floor(p.random(0, bgColors.length))];
      p.background(bgColor[0], bgColor[1], bgColor[2]);

      switch(style) {
        case 'Modern': drawModern(p, heightFactor); break;
        case 'Classical': drawClassical(p, heightFactor); break;
        case 'Realist': drawRealist(p, heightFactor); break;
        case 'Natural': drawNatural(p, heightFactor); break;
        case 'AI-Generated': drawAIGenerated(p, heightFactor); break;
        case 'Other-Worldly': drawOtherWorldly(p, heightFactor); break;
        case 'Fractal': drawFractal(p, heightFactor); break;
        case 'Surrealist': drawSurrealist(p, heightFactor); break;
        case 'Cyberpunk': drawCyberpunk(p, heightFactor); break;
        case 'Expressionist': drawExpressionist(p, heightFactor); break;
        case 'Cubist': drawCubist(p, heightFactor); break;
        case 'Impressionist': drawImpressionist(p, heightFactor); break;
        case 'Minimalist': drawMinimalist(p, heightFactor); break;
        case 'Pixel': drawPixel(p, heightFactor); break;
        case 'Vaporwave': drawVaporwave(p, heightFactor); break;
        case 'Glitch': drawGlitch(p, heightFactor); break;
        case 'Geometric': drawGeometric(p, heightFactor); break;
        case 'Watercolor': drawWatercolor(p, heightFactor); break;
        case 'Blueprint': drawBlueprint(p, heightFactor); break;
        case 'Stained Glass': drawStainedGlass(p, heightFactor); break;
        default: drawModern(p, heightFactor);
      }

      // Restore canvas state if we used clipping or transformations
      if (p.drawingContext._stack && p.drawingContext._stack.length > 0) {
        p.drawingContext.restore();
      }
    }

    // Modern: Bold, minimalist shapes
    function drawModern(p, heightFactor) {
      const numShapes = 5 + Math.floor(heightFactor * 10);
      for (let i = 0; i < numShapes; i++) {
        p.fill(p.random(255), p.random(255), p.random(255));
        p.noStroke();
        const x = p.random(p.width);
        const y = p.random(p.height);
        const size = p.random(50, 200) * heightFactor;
        if (p.random() > 0.5) {
          p.rect(x, y, size, size);
        } else {
          p.ellipse(x, y, size, size);
        }
      }
    }

    // Classical: Ornate, symmetrical patterns
    function drawClassical(p, heightFactor) {
      const numArcs = 10 + Math.floor(heightFactor * 20);
      p.strokeWeight(2);
      for (let i = 0; i < numArcs; i++) {
        p.stroke(p.random(100, 200), p.random(50, 150), 50, 150);
        p.noFill();
        const x = p.width / 2;
        const y = p.height / 2;
        const radius = p.random(50, 300) * heightFactor;
        p.arc(x, y, radius, radius, p.random(p.TWO_PI), p.random(p.TWO_PI));
      }
    }

    // Realist: Simplified landscape
    function drawRealist(p, heightFactor) {
      // Ground
      p.fill(100, 150, 50);
      p.rect(0, p.height * 0.6, p.width, p.height * 0.4);
      // Trees
      const numTrees = 5 + Math.floor(heightFactor * 10);
      for (let i = 0; i < numTrees; i++) {
        const x = p.random(p.width);
        const y = p.random(p.height * 0.6, p.height * 0.8);
        p.fill(139, 69, 19);
        p.rect(x - 10, y, 20, p.height - y);
        p.fill(34, 139, 34);
        p.ellipse(x, y - 20, 50, 50);
      }
    }

    // Natural: Organic, flowing forms
    function drawNatural(p, heightFactor) {
      const numCurves = 10 + Math.floor(heightFactor * 20);
      p.strokeWeight(3);
      for (let i = 0; i < numCurves; i++) {
        p.stroke(p.random(50, 150), p.random(100, 200), 50);
        p.noFill();
        p.beginShape();
        p.curveVertex(p.random(p.width), p.random(p.height));
        p.curveVertex(p.random(p.width), p.random(p.height));
        p.curveVertex(p.random(p.width), p.random(p.height));
        p.curveVertex(p.random(p.width), p.random(p.height));
        p.endShape();
      }
    }

    // AI-Generated: Glitchy, pixelated patterns
    function drawAIGenerated(p, heightFactor) {
      const numGlitches = 50 + Math.floor(heightFactor * 100);
      for (let i = 0; i < numGlitches; i++) {
        const x = p.random(p.width);
        const y = p.random(p.height);
        const size = p.random(5, 20);
        p.fill(p.random(255), p.random(255), p.random(255), 200);
        p.noStroke();
        p.rect(x, y, size, size);
        if (p.random() > 0.7) {
          p.stroke(255, 0, 255);
          p.line(x, y, x + p.random(-20, 20), y + p.random(-20, 20));
        }
      }
    }

    // Other-Worldly: Alien, bioluminescent shapes
    function drawOtherWorldly(p, heightFactor) {
      const numShapes = 10 + Math.floor(heightFactor * 20);
      for (let i = 0; i < numShapes; i++) {
        const x = p.random(p.width);
        const y = p.random(p.height);
        const size = p.random(30, 100) * heightFactor;
        p.fill(p.random(0, 50), p.random(150, 255), p.random(150, 255), 150);
        p.noStroke();
        p.ellipse(x, y, size, size * p.random(0.5, 1.5));
      }
    }

    // Fractal: Recursive patterns
    function drawFractal(p, heightFactor) {
      function drawBranch(x, y, len, angle, depth) {
        if (depth === 0) return;
        p.stroke(255, 255 / depth, 255 / depth);
        p.strokeWeight(depth);
        const x2 = x + len * p.cos(angle);
        const y2 = y + len * p.sin(angle);
        p.line(x, y, x2, y2);
        drawBranch(x2, y2, len * 0.7, angle + p.random(-p.PI / 4, p.PI / 4), depth - 1);
        drawBranch(x2, y2, len * 0.7, angle + p.random(-p.PI / 4, p.PI / 4), depth - 1);
      }
      drawBranch(p.width / 2, p.height, 100 * heightFactor, -p.PI / 2, 5);
    }

    // Surrealist: Dreamlike, distorted shapes
    function drawSurrealist(p, heightFactor) {
      const numShapes = 10 + Math.floor(heightFactor * 20);
      for (let i = 0; i < numShapes; i++) {
        const x = p.random(p.width);
        const y = p.random(p.height);
        const size = p.random(50, 150) * heightFactor;
        p.fill(p.random(255), p.random(255), p.random(255), 100);
        p.noStroke();
        p.beginShape();
        for (let j = 0; j < 6; j++) {
          p.vertex(x + p.random(-size, size), y + p.random(-size, size));
        }
        p.endShape(p.CLOSE);
      }
    }

    // Cyberpunk: Neon grids
    function drawCyberpunk(p, heightFactor) {
      const gridSize = 20 + Math.floor(heightFactor * 30);
      for (let x = 0; x < p.width; x += gridSize) {
        for (let y = 0; y < p.height; y += gridSize) {
          p.stroke(p.random(0, 255), p.random(150, 255), 255, 150);
          p.strokeWeight(1);
          p.line(x, y, x + gridSize, y);
          p.line(x, y, x, y + gridSize);
          if (p.random() > 0.8) {
            p.fill(255, 0, 255, 100);
            p.noStroke();
            p.ellipse(x, y, gridSize / 2);
          }
        }
      }
    }

    // Expressionist: Jagged, emotional strokes
    function drawExpressionist(p, heightFactor) {
      const numStrokes = 20 + Math.floor(heightFactor * 30);
      p.strokeWeight(5);
      for (let i = 0; i < numStrokes; i++) {
        const x1 = p.random(p.width);
        const y1 = p.random(p.height);
        const x2 = x1 + p.random(-50, 50);
        const y2 = y1 + p.random(-50, 50);
        p.stroke(p.random(255), p.random(255), p.random(255));
        p.line(x1, y1, x2, y2);
      }
    }

    // Cubist: Overlapping geometric planes
    function drawCubist(p, heightFactor) {
      const numPlanes = 10 + Math.floor(heightFactor * 20);
      for (let i = 0; i < numPlanes; i++) {
        p.fill(p.random(150, 250), p.random(150, 250), p.random(150, 250), 150);
        p.stroke(50);
        p.strokeWeight(1);
        p.beginShape();
        const x = p.random(p.width);
        const y = p.random(p.height);
        const size = p.random(50, 120);
        for (let j = 0; j < 4; j++) {
          p.vertex(x + p.random(-size, size), y + p.random(-size, size));
        }
        p.endShape(p.CLOSE);
      }
    }

    // Impressionist: Small, visible brushstrokes
    function drawImpressionist(p, heightFactor) {
      const numStrokes = 500 + Math.floor(heightFactor * 1000);
      for (let i = 0; i < numStrokes; i++) {
        const x = p.random(p.width);
        const y = p.random(p.height);
        const size = p.random(2, 8);
        // Create harmonious color palette
        const baseHue = p.random(360);
        const saturation = p.random(40, 80);
        const brightness = p.random(70, 100);
        p.colorMode(p.HSB, 360, 100, 100, 100);
        p.fill(baseHue, saturation, brightness, 50);
        p.noStroke();
        p.ellipse(x, y, size, size);
        p.colorMode(p.RGB, 255, 255, 255, 255);
      }
    }

    // Minimalist: Sparse, geometric elements
    function drawMinimalist(p, heightFactor) {
      const numElements = 1 + Math.floor(heightFactor * 3);
      const colors = [
        [0, 0, 0],      // Black
        [255, 255, 255], // White
        [255, 0, 0],     // Red
        [0, 0, 255],     // Blue
        [255, 255, 0]    // Yellow
      ];
      for (let i = 0; i < numElements; i++) {
        const color = colors[Math.floor(p.random(colors.length))];
        p.fill(color[0], color[1], color[2]);
        p.noStroke();
        const shapeType = Math.floor(p.random(3));
        const x = p.random(p.width * 0.2, p.width * 0.8);
        const y = p.random(p.height * 0.2, p.height * 0.8);
        const size = p.random(50, 200);
        if (shapeType === 0) {
          p.rect(x, y, size, size);
        } else if (shapeType === 1) {
          p.ellipse(x, y, size, size);
        } else {
          p.beginShape();
          p.vertex(x, y);
          p.vertex(x + size, y);
          p.vertex(x + size/2, y + size);
          p.endShape(p.CLOSE);
        }
      }
    }

    // Pixel: 8-bit style pixelated art
    function drawPixel(p, heightFactor) {
      const pixelSize = 15 + Math.floor(heightFactor * 20);
      p.noStroke();
      for (let x = 0; x < p.width; x += pixelSize) {
        for (let y = 0; y < p.height; y += pixelSize) {
          if (p.random() > 0.7) {
            p.fill(p.random(255), p.random(255), p.random(255));
            p.rect(x, y, pixelSize, pixelSize);
          }
        }
      }
      const numElements = 3 + Math.floor(heightFactor * 5);
      for (let i = 0; i < numElements; i++) {
        const x = Math.floor(p.random(p.width / pixelSize)) * pixelSize;
        const y = Math.floor(p.random(p.height / pixelSize)) * pixelSize;
        const size = Math.floor(p.random(2, 6)) * pixelSize;
        p.fill(p.random(100, 255), p.random(100, 255), p.random(100, 255));
        for (let px = 0; px < size; px += pixelSize) {
          for (let py = 0; py < size; py += pixelSize) {
            if (p.random() > 0.3) {
              p.rect(x + px, y + py, pixelSize, pixelSize);
            }
          }
        }
      }
    }

    // Vaporwave: Retro digital aesthetic
    function drawVaporwave(p, heightFactor) {
      p.background(0, 0, 30);
      for (let y = 0; y < p.height; y++) {
        const inter = p.map(y, 0, p.height, 0, 1);
        const c = p.lerpColor(p.color(255, 100, 200), p.color(100, 200, 255), inter);
        p.stroke(c);
        p.line(0, y, p.width, y);
      }
      p.stroke(255, 255, 0, 100);
      for (let x = 0; x < p.width; x += 20) {
        p.line(x, 0, x, p.height);
      }
      for (let y = 0; y < p.height; y += 20) {
        p.line(0, y, p.width, y);
      }
      p.fill(255, 50, 150);
      p.noStroke();
      p.ellipse(p.width/2, p.height/2, 200 * heightFactor, 200 * heightFactor);
      for (let i = 0; i < 10; i++) {
        p.fill(0, 255, 255, 150);
        p.rect(p.random(p.width), p.random(p.height), 50, 50);
      }
    }

    // Glitch: Digital corruption aesthetics
    function drawGlitch(p, heightFactor) {
      for (let i = 0; i < 20; i++) {
        p.fill(p.random(255), p.random(255), p.random(255), 150);
        p.noStroke();
        p.rect(0, p.random(p.height), p.width, p.random(5, 20));
      }
      const numGlitches = 30 + Math.floor(heightFactor * 50);
      for (let i = 0; i < numGlitches; i++) {
        if (p.random() > 0.5) {
          p.stroke(p.random(255), p.random(255), p.random(255));
          p.strokeWeight(p.random(1, 5));
          const y = p.random(p.height);
          p.line(0, y, p.width, y);
        } else {
          p.stroke(p.random(255), p.random(255), p.random(255));
          p.strokeWeight(p.random(1, 5));
          const x = p.random(p.width);
          p.line(x, 0, x, p.height);
        }
        if (p.random() > 0.8) {
          p.noStroke();
          p.fill(255, 0, 0, 100);
          const x = p.random(p.width);
          const y = p.random(p.height);
          const w = p.random(20, 100);
          const h = p.random(5, 20);
          p.rect(x, y, w, h);
          p.fill(0, 255, 0, 100);
          p.rect(x + p.random(-10, 10), y, w, h);
          p.fill(0, 0, 255, 100);
          p.rect(x, y + p.random(-10, 10), w, h);
        }
      }
    }

    // Geometric: Pure mathematical geometry
    function drawGeometric(p, heightFactor) {
      const numShapes = 5 + Math.floor(heightFactor * 15);
      for (let i = 0; i < numShapes; i++) {
        const x = p.random(p.width);
        const y = p.random(p.height);
        const size = p.random(30, 120);
        p.stroke(0);
        p.strokeWeight(2);
        p.fill(p.random(255), p.random(255), p.random(255), 150);
        const shapeType = Math.floor(p.random(5));
        if (shapeType === 0) {
          p.triangle(
            x, y,
            x + size, y,
            x + size/2, y - size
          );
        } else if (shapeType === 1) {
          p.rect(x, y, size, size * p.random(0.5, 1.5));
        } else if (shapeType === 2) {
          p.ellipse(x, y, size, size);
        } else if (shapeType === 3) {
          p.beginShape();
          for (let j = 0; j < 5; j++) {
            const angle = p.TWO_PI * j / 5 - p.HALF_PI;
            const px = x + size/2 * p.cos(angle);
            const py = y + size/2 * p.sin(angle);
            p.vertex(px, py);
          }
          p.endShape(p.CLOSE);
        } else {
          p.beginShape();
          for (let j = 0; j < 6; j++) {
            const angle = p.TWO_PI * j / 6;
            const px = x + size/2 * p.cos(angle);
            const py = y + size/2 * p.sin(angle);
            p.vertex(px, py);
          }
          p.endShape(p.CLOSE);
        }
      }
    }

    // Watercolor: Soft, blended colors
    function drawWatercolor(p, heightFactor) {
      p.background(240, 240, 240);
      const numBlobs = 10 + Math.floor(heightFactor * 20);
      for (let i = 0; i < numBlobs; i++) {
        const baseHue = p.random(360);
        const colorVariation = 30;
        p.colorMode(p.HSB, 360, 100, 100, 100);
        const hue = (baseHue + p.random(-colorVariation, colorVariation)) % 360;
        const saturation = p.random(30, 70);
        const brightness = p.random(60, 95);
        p.fill(hue, saturation, brightness, 30);
        p.colorMode(p.RGB, 255, 255, 255, 255);
        p.noStroke();
        p.beginShape();
        const x = p.random(p.width);
        const y = p.random(p.height);
        const radius = p.random(50, 200) * heightFactor;
        const points = 12;
        for (let j = 0; j < points; j++) {
          const angle = p.TWO_PI * j / points;
          const r = radius * (0.7 + p.random(0.5));
          const px = x + r * p.cos(angle);
          const py = y + r * p.sin(angle);
          p.curveVertex(px, py);
        }
        p.endShape(p.CLOSE);
      }
      for (let i = 0; i < 200; i++) {
        p.stroke(255, 255, 255, 10);
        p.strokeWeight(p.random(1, 3));
        const x1 = p.random(p.width);
        const y1 = p.random(p.height);
        const x2 = x1 + p.random(-30, 30);
        const y2 = y1 + p.random(-30, 30);
        p.line(x1, y1, x2, y2);
      }
    }

    // Blueprint: Technical drawings
    function drawBlueprint(p, heightFactor) {
      p.background(0, 50, 100);
      p.stroke(100, 150, 255, 50);
      p.strokeWeight(0.5);
      const gridSize = 20;
      for (let x = 0; x < p.width; x += gridSize) {
        p.line(x, 0, x, p.height);
      }
      for (let y = 0; y < p.height; y += gridSize) {
        p.line(0, y, p.width, y);
      }
      p.stroke(200, 230, 255);
      p.strokeWeight(1);
      p.noFill();
      const numElements = 5 + Math.floor(heightFactor * 10);
      for (let i = 0; i < numElements; i++) {
        const x = p.random(p.width);
        const y = p.random(p.height);
        const size = p.random(40, 150);
        if (p.random() > 0.5) {
          p.ellipse(x, y, size, size);
          p.line(x - size/2, y, x + size/2, y);
          p.line(x, y - size/2, x, y + size/2);
          p.line(x - size/2, y + size/2 + 10, x + size/2, y + size/2 + 10);
          p.line(x - size/2, y + size/2 + 5, x - size/2, y + size/2 + 15);
          p.line(x + size/2, y + size/2 + 5, x + size/2, y + size/2 + 15);
        } else {
          p.rect(x, y, size, size * 0.6);
          p.line(x, y, x + size, y + size * 0.6);
          p.line(x + size, y, x, y + size * 0.6);
          p.line(x, y - 10, x + size, y - 10);
          p.line(x, y - 5, x, y - 15);
          p.line(x + size, y - 5, x + size, y - 15);
        }
        p.fill(200, 230, 255);
        p.textSize(8);
        p.text(Math.round(size).toString(), x, y);
      }
    }

    // Stained Glass: Colorful panels with black borders
    function drawStainedGlass(p, heightFactor) {
      const numPoints = 10 + Math.floor(heightFactor * 20);
      const points = [];
      for (let i = 0; i < numPoints; i++) {
        points.push({
          x: p.random(p.width),
          y: p.random(p.height)
        });
      }
      for (let x = 0; x < p.width; x += 5) {
        for (let y = 0; y < p.height; y += 5) {
          let closestDist = Number.MAX_VALUE;
          let closestIndex = 0;
          for (let i = 0; i < points.length; i++) {
            const d = p.dist(x, y, points[i].x, points[i].y);
            if (d < closestDist) {
              closestDist = d;
              closestIndex = i;
            }
          }
          p.colorMode(p.HSB, 360, 100, 100);
          const hue = (closestIndex * 30) % 360;
          p.fill(hue, 80, 90);
          p.noStroke();
          p.rect(x, y, 5, 5);
        }
      }
      p.colorMode(p.RGB, 255, 255, 255);
      for (let i = 0; i < points.length; i++) {
        for (let j = i + 1; j < points.length; j++) {
          const midX = (points[i].x + points[j].x) / 2;
          const midY = (points[i].y + points[j].y) / 2;
          if (p.dist(points[i].x, points[i].y, points[j].x, points[j].y) < 150) {
            p.stroke(0);
            p.strokeWeight(2);
            p.line(points[i].x, points[i].y, midX, midY);
          }
        }
      }
    }

    // Load and display previous blocks
    function loadPreviousBlocks() {
      const prevDiv = document.getElementById('previous-blocks');
      prevDiv.innerHTML = ''; // Clear previous thumbnails if any
      fetchPreviousBlocks().then(blocks => {
        blocks.forEach(block => {
          const { randomizer, seed } = createRandomizer(block.blockHash, block.blockHeight);
          const container = document.createElement('div');
          container.className = 'thumbnail';
          container.title = `Block ${block.blockHeight}`;
          prevDiv.appendChild(container);
          new p5(p => {
            p.setup = function() {
              p.createCanvas(100, 100);
              p.randomSeed(seed);
              const styles = [
                'Modern', 'Classical', 'Realist', 'Natural', 'AI-Generated',
                'Other-Worldly', 'Fractal', 'Surrealist', 'Cyberpunk', 'Expressionist',
                'Cubist', 'Impressionist', 'Minimalist', 'Pixel', 'Vaporwave',
                'Glitch', 'Geometric', 'Watercolor', 'Blueprint', 'Stained Glass'
              ];
              const styleIndex = Math.floor(p.random(0, styles.length));
              const style = styles[styleIndex];
              console.log(`Thumbnail for block ${block.blockHeight} - Seed: ${seed}, Style: ${style}`);
              drawArt(p, block.blockHeight, style);
              container.addEventListener('click', () => {
                if (mainSketch) {
                  mainSketch.remove();
                }
                mainSketch = new p5(p2 => {
                  p2.setup = function() {
                    const canvas = p2.createCanvas(600, 600);
                    canvas.parent('main-canvas');
                    p2.randomSeed(seed);
                    const selectedStyleIndex = Math.floor(p2.random(0, styles.length));
                    const selectedStyle = styles[selectedStyleIndex];
                    console.log(`Main sketch (from thumbnail) - Seed: ${seed}, Style: ${selectedStyle}`);
                    updateInfo(block.blockHash, block.blockHeight, randomizer, selectedStyle);
                    const canvasStyles = ['Standard', 'Circular', 'Framed', 'Divided', 'Layered'];
                    const canvasStyle = canvasStyles[Math.floor(p2.random(0, canvasStyles.length))];
                    setupCanvas(p2, canvasStyle);
                    drawArt(p2, block.blockHeight, selectedStyle);
                  };
                });
              });
            };
          }, container);
        });
      }).catch(error => {
        console.error('Error rendering previous blocks:', error);
        prevDiv.innerHTML = '<p>Could not load previous blocks</p>';
      });
    }

    // Main sketch setup
    function mainSketchSetup(p) {
      p.setup = function() {
        const canvas = p.createCanvas(600, 600);
        canvas.parent('main-canvas');
        p.background(255);
        fetchBlockData().then(({ blockHash, blockHeight }) => {
          currentBlockHeight = blockHeight;
          const { randomizer, seed } = createRandomizer(blockHash, blockHeight);
          p.randomSeed(seed);
          const styles = [
            'Modern', 'Classical', 'Realist', 'Natural', 'AI-Generated',
            'Other-Worldly', 'Fractal', 'Surrealist', 'Cyberpunk', 'Expressionist',
            'Cubist', 'Impressionist', 'Minimalist', 'Pixel', 'Vaporwave',
            'Glitch', 'Geometric', 'Watercolor', 'Blueprint', 'Stained Glass'
          ];
          const styleIndex = Math.floor(p.random(0, styles.length));
          const style = styles[styleIndex];
          console.log(`Main sketch - Seed: ${seed}, Style: ${style}`);
          const infoDiv = document.getElementById('info');
          if (blockHash.includes('abcdef') || blockHash.length < 30) {
            infoDiv.innerHTML = `Using generated data (API unavailable)<br>Block Height: ${blockHeight}<br>Block Hash (Last 6): ${blockHash.slice(-6)}<br>Style: ${style}`;
          } else {
            updateInfo(blockHash, blockHeight, randomizer, style);
          }
          const canvasStyles = ['Standard', 'Circular', 'Framed', 'Divided', 'Layered'];
          const canvasStyle = canvasStyles[Math.floor(p.random(0, canvasStyles.length))];
          setupCanvas(p, canvasStyle);
          drawArt(p, blockHeight, style);
          startBlockPolling();
          setFallbackReload();
          loadPreviousBlocks();
        }).catch(error => {
          console.error('Complete failure in setup:', error);
          const infoDiv = document.getElementById('info');
          infoDiv.innerHTML = 'Error generating artwork. Using fallback data.';
          const fallbackHeight = '770000';
          const fallbackHash = '00000000000000000004a7ade8436b2b15d71302c187926e5c9764369daae94f';
          const { randomizer, seed } = createRandomizer(fallbackHash, fallbackHeight);
          p.randomSeed(seed);
          const style = 'Modern';
          setupCanvas(p, 'Standard');
          drawArt(p, fallbackHeight, style);
          loadPreviousBlocks();
        });
      };
    }

    // Initialize main sketch
    mainSketch = new p5(mainSketchSetup);
  </script>
</body>
</html>